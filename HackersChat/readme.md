sstf2019 - HackersChat
----------------------

```
debian - glibc 2.23 , ELF64.

CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```
풀이는 tcache가 적용되지 않은 우분투 16.04 환경에서 진행했다. 

실행시 유저이름을 물어보고 rbp-0x104위치에 
0x20 바이트만큼 패스워드를 입력하게 하고 개행문자가 들어왔는지 체크한다. 
이는 패스워드에서도 마찬가지. 

이후 입력한 아이디와 패스워드, 포인터 두개를 인자로 함수를 호출하는데,
cred_file 에서 읽어온 내용과 일치하는지를 비교한다. 

이때 이 함수의 인자로 같이 들어갔던 포인터 둘에 읽어왔던 파일의 내용이 담기게 된다. 

이중 비밀번호와 비교되는 정답 문자열이 스택에서 아이디 배열 바로 앞에 위치하게 되어
sprintf 함수가 호출될 떄 아이디 배열을 32바이트로 가득 채운 상태라면 
연속적으로 다음 스택까지 읽어와서 비밀번호를 출력하게 된다. 

아이디를 admin으로 하고 읽어온 패스워드를 사용해 로그인하면 로그인에 성공한다. 
메뉴가 4개가 나오는데, 각각 메시지 읽어오기, 보내기, 삭제하기, 로그아웃 순이다. 

읽어오는 메뉴에선 패스워드를 입력하면 모든 메시지 내용을 볼 수 있다. 

보내는 메뉴에선 최대 0x3E7바이트 중 입력한 문자열 바이트수 만큼 힙 메모리를 할당하고, 
전역변수 영역 배열에 힙의 주소를 저장시킨다. 

삭제 메뉴에선 인덱스에 따라 할당한 메모리를 할당 해제시킨다. 

우선 더블프리 유발이 가능한지부터 확인봤는데, 
일반적인 방법으로는 힘들어보인다. 

주소 leak 또한 삭제 후 초기화가 이뤄지기 때문에 힘들어 보였다. 
(심지어 디버깅 심볼도 제대로 안잡힌다. )

베열에 저장되는 순서는 메모리 상 순서에 무관하게 할당한 순서부터였다. 

앞 배열을 할당 해제 후 꽉 차게 재할당하는 경우, 
배열의 맨 끝바이트에 추가로 붙는 0x00이 
다음 배열의 사이즈 배열을 날려버리는 문제를 발견했다. 

그 상태에서 사이즈가 사라진 메모리와 동일한 크기 힙을 할당해제/할당 시도하면 에러가 발생한다.

그러나 청크의 사이즈가 0x100 이상일 경우엔 하위 2바이트만 0이 되고 나머지는 멀쩡하다.  

이렇게 만든 이후에 할당 해제를 시도하면 prev_size 불일치 에러가 발생한다. 

현재버전 libc에서는 일정 크기이상의(unsorted bin)청크를 할당 해제하고,
할당 해제된 청크들이 인접할 시 서로 병합된다. 
서로 병합되는 점을 이용하여 익스플로잇을 진행해야할듯 하다. 

일단 , 0x100,0x70,0x100,0x10 크기의 청크들을 각각 할당한다.  
그 다음, 맨 앞 청크(0x100)와 그 다음번 청크(0x70)를 할당 해제한다. 

0x101 로 되어 할당된 청크를 이전에 있는 0x70크기 청크를 이용해 100으로 바꿔준 다음,
prev size를 맞춰줘야 하기에 마지막 바이트를 00으로 덮은 동작을 이용해 
prev size를 깔끔하게 0x170으로 채워준다. 

그 다음, 0x70사이즈 다음에 할당된 0x100 청크를 할당 해제하면 
prev_inuse 비트가 0이고, size도 170으로 맞춰져 있으므로 
맨 처음 청크부터 세번째 청크까지 병합이 진행된다. 

그 다음 0x100크기의 새로운 청크를 할당 시도하면 0x70 청크는 
할당 해제되지 않았음에도 불구하고 , 
할당 해제+ 다음에 존재하는 0x100청크와 병합된 
0x170짜리 unsorted bin 취급을 받게 되어 
fd와 bk에 main_arena의 주소가 들어가게 된다. 

이때 0x70짜리 청크에 대해 출력을 시도하면 데이터 영역에 있는 
주소값들이 출력될 것이다.  

libc주소를 얻어냈으면 아까 했던것 처럼 prev_size를 비롯한 청크를 다시 정리해주자. 
이떄 0x70 청크를 원상 복구 해줘야하므로,  맨 앞청크를 다시 할당 해제하고, 
원래 0x70 청크의 size 위치에 다시 0x70 이 위치할 수 있게끔 한다. 

그 다음 맨 앞청크 -> 0x70 청크 순으로 할당 해제하면 
0x70 청크가 정상적으로 할당 해제된다.  
그러나 0x70 size를 복구하고 맨 앞청크를 다시 할당 해제하는 시점에서 
다시 전체 병합이 일어나 0x270짜리 큰 청크가 만들어지고, 
0x70은 할당 해제된 청크 취급을 받게 된다. 

할당 해제된 청크를 다시 할당 할 때, 해당 청크의 fd에 있는 주소를 반환하여 다음번에 동일한 크기를 가지는 청크를 할당할 목표 위치로 사용한다.  그러므로 이번엔 fd에 free_hook의 주소를 가지는 0x70 청크를 임의로 만들어줘야 한다.  

그 다음 이전과 마찬가지로 청크가 할당해제 될 수 있게 prev_size를 세팅해주자. 

이후 0x70 짜리 청크에 할당을 두번 진행하면, 
두번째 할당시에 free_hook에 할당을 진행할거다. 

그리고 할당 진행시 유의해야 하는점은, 
free_hook 앞부분에서 0x7f 로 끝나는 바이트를 찾아 그 바이트를 size 로 위치하게끔 주소를 지정해줘야 한다는것. 

free_hook은 근처에 그런 메모리 영역이 없기에 사용하기에 부적합하다. 
malloc_hook을 사용하자.  그리고 지정 주소 +0x10 부터 데이터 영역이 시작되는점을 감안하여 오프셋 계산 진행 후에 할당을 시작하면 된다.  

사이즈가 들어가는 영역의 기준은, 
바로 뒤 prev_size 취급받을 영역 (4바이트) 에 값이 없어야 하고, 
사이즈 영역 8바이트에는 7f값만 들어가 있어야한다. 

모든 세팅이 끝나면, 아무 바이트나 할당을 진행하면 쉘이 떨어진다. 







